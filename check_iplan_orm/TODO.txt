
def compose_predict_df(df_past: DataFrame,
                       area_dict: dict[int, str],
                       skill_dict: dict[int, str],
                       input_measure_ids: list[int],
                       measure_dict: dict[int, str],
                       start_end_dates: dict[int, tuple[datetime, datetime]],
                       freq: Literal['D', 'W', 'M'],
                       defval: Union[None, float] = 0.,
                       new_format=False) -> DataFrame:
    """

    :param df_past: dataframe to process
    :param area_dict: dictionary area id->name
    :param skill_dict: dictionary skill id->name
    :param input_measure_ids: list of measures used as input features
    :param measure_dict: dictionary measure id->name
    :param start_end_dates: dictionary start/end dates for each area
    :param freq: period frequency (daily, weekly, monthly)
    :param defval: default value to use for filling
    :param new_format: dataset format (old/new)
    :return: processed dataset
    """
    assert is_instance(df_past, DataFrame)
    assert is_instance(area_dict, dict[int, str])
    assert is_instance(skill_dict, dict[int, str])
    assert is_instance(input_measure_ids, list[int])
    assert is_instance(measure_dict, dict[int, str])
    assert is_instance(start_end_dates, dict[int, tuple[datetime, datetime]])
    assert is_instance(freq, Literal['D', 'W', 'M'])
    assert is_instance(defval, Union[None, float])

    df_future = _create_df_future(
        df_past,
        area_dict, skill_dict,
        input_measure_ids, measure_dict,
        start_end_dates, freq, defval,
        new_format=new_format)

    df_future = _merge_df_past_future(
        df_past, df_future,
        input_measure_ids, measure_dict,
        new_format=new_format)
    return df_future


def _create_df_future(
    df_past: DataFrame,
    area_dict: dict[int, str],
    skill_dict: dict[int, str],
    input_measure_ids: list[int],
    measure_dict: dict[int, str],
    start_end_dates: dict[int, tuple[datetime, datetime]],
    freq: Literal['D', 'W', 'M'],
    defval: Union[None, float] = 0.,
    new_format=False
) -> DataFrame:
    if new_format:
        df_future = _create_df_future_new_format(
            df_past,
            area_dict,
            skill_dict,
            input_measure_ids,
            measure_dict,
            start_end_dates, freq,
            defval)

        # return _compose_predict_df_new_format(
        #     df_past,
        #     area_dict,
        #     skill_dict,
        #     input_measure_ids,
        #     measure_dict,
        #     start_end_dates, freq,
        #     defval)
    else:
        df_future = _create_df_future_old_format(
            df_past,
            area_dict,
            skill_dict,
            input_measure_ids,
            measure_dict,
            start_end_dates, freq,
            defval)

    return df_future


def _create_df_future_new_format(
    df_past: DataFrame,
    area_dict: dict[int, str],
    skill_dict: dict[int, str],
    input_measure_ids: list[int],
    measure_dict: dict[int, str],
    start_end_dates: dict[int, tuple[datetime, datetime]],
    freq: Literal['D', 'W', 'M'],
    defval: Union[None, float] = 0.) -> DataFrame:
    area_drev = reverse_dict(area_dict)
    skill_drev = reverse_dict(skill_dict)
    measure_drev = reverse_dict(measure_dict)

    # columns: ['area', 'skill', 'date', <measure_name>]

    area_skill_list = pdx.groups_list(df_past, groups=['area', 'skill'])
    df_future_list = []
    for area_skill in area_skill_list:
        area_name, skill_name = area_skill

        # check if area_name, skill_name are defined
        if area_name not in area_drev or skill_name not in skill_drev:
            continue

        area_id = area_drev[area_name]
        # skill_id = skill_drev[skill_name]

        # trick: 0 is used as DEFAULT datetime for all areas
        if 0 in start_end_dates:
            start_date, end_date = start_end_dates[0]
        elif area_id in start_end_dates:
            start_date, end_date = start_end_dates[area_id]
        else:
            # no start/end dates is found
            continue

        #  FutureWarning: 'M' is deprecated and will be removed in a future version, please use 'ME' instead.
        #   MS: MonthBegin
        #   ME: MonthEnd
        if freq == 'M': freq = 'MS'

        date_index = pd.date_range(start=start_date, end=end_date, freq=freq)
        # date_index = pd.period_range(start=start_date, end=end_date, freq=freq)

        # create the dataframe
        area_skill_df = DataFrame(data={
            'area': area_name,
            'skill': skill_name,
            'date': date_index.to_series()
        })

        # fill the dataframe with the measures
        for measure_name in measure_drev:
            area_skill_df[measure_name] = defval

        df_future_list.append(area_skill_df)
        pass
    # end
    df_future = pd.concat(df_future_list, axis=0, ignore_index=True).reset_index(drop=True)
    return df_future


def _create_df_future_old_format(
    df_past: DataFrame,
    area_dict: dict[int, str],
    skill_dict: dict[int, str],
    input_measure_ids: list[int],
    measure_dict: dict[int, str],
    start_end_dates: dict[int, tuple[datetime, datetime]],
    freq: Literal['D', 'W', 'M'],
    defval: Union[None, float] = 0.) -> DataFrame:
    # columns: ['skill_id_fk', 'area_id_fk', 'time', 'day', <measure_id: str>]

    area_skill_list = pdx.groups_list(df_past, groups=['area_id_fk', 'skill_id_fk'])
    df_future_list = []
    for area_skill in area_skill_list:
        area_id = int(area_skill[0])
        skill_id = int(area_skill[1])

        # check if area_name, skill_name are defined
        if area_id not in area_dict or skill_id not in skill_dict:
            continue

        # trick: 0 is used as DEFAULT datetime for all areas
        if 0 in start_end_dates:
            start_date, end_date = start_end_dates[0]
        elif area_id in start_end_dates:
            start_date, end_date = start_end_dates[area_id]
        else:
            # no start/end dates is found
            continue

        #  FutureWarning: 'M' is deprecated and will be removed in a future version, please use 'ME' instead.
        #   MS: MonthBegin
        #   ME: MonthEnd
        if freq == 'M': freq = 'MS'

        date_index = pd.date_range(start=start_date, end=end_date, freq=freq)
        # date_index = pd.period_range(start=start_date, end=end_date, freq=freq)

        # create the dataframe
        area_skill_df = DataFrame(data={
            'area_id_fk': area_id,
            'skill_id_fk': skill_id,
            'time': date_index.to_series()
        })
        area_skill_df['day'] = area_skill_df['time'].dt.day_name()

        # fill the dataframe with the measures (measure_id as string)
        for measure_id in measure_dict:
            area_skill_df[str(measure_id)] = defval

        df_future_list.append(area_skill_df)
        pass
    # end

    df_future = pd.concat(df_future_list, axis=0, ignore_index=True).reset_index(drop=True)
    return df_future


def _merge_df_past_future(df_past: DataFrame, df_future: DataFrame,
                          input_measure_ids: list[int], measure_dict: dict[int, str],
                          new_format=True) -> DataFrame:
    assert is_instance(df_past, DataFrame)
    assert is_instance(df_future, DataFrame)
    assert is_instance(input_measure_ids, list[int])
    assert is_instance(measure_dict, dict[int, str])
    assert sorted(df_past.columns) == sorted(df_future.columns)

    groups = ['area', 'skill'] if new_format else ['area_id_fk', 'skill_id_fk']
    date_col = 'date' if new_format else 'time'

    df_past_dict = pdx.groups_split(df_past, groups=groups)
    df_future_dict = pdx.groups_split(df_future, groups=groups)
    df_predict_dict = {}

    for group in df_future_dict:
        if group not in df_past_dict:
            continue

        dfp = df_past_dict[group]
        dff = df_future_dict[group]

        past_min = dfp[date_col].min()
        past_max = dfp[date_col].max()
        future_min = dff[date_col].min()
        future_max = dff[date_col].max()

        if past_max < future_min:
            df_predict_dict[group] = dff
        elif past_max >= future_max:
            continue
        elif past_min < future_min < past_max:
            df_predict_dict[group] = dff[dff[date_col] > past_min]
        else:
            continue
    # end

    df_pred = pdx.groups_merge(df_predict_dict, groups=groups)
    df_merged = pd.concat([df_pred, df_future], axis=0, ignore_index=True)
    return df_merged


def _compose_predict_df_old_format(
    df_past: DataFrame,
    area_dict: dict[int, str],
    skill_dict: dict[int, str],
    input_measure_ids: list[int],
    measure_dict: dict[int, str],
    start_end_dates: dict[int, tuple[datetime, datetime]],
    freq: Literal['D', 'W', 'M'],
    defval: Union[None, float] = 0.) -> DataFrame:
    # columns: ['skill_id_fk', 'area_id_fk', 'time', 'day', <measure_id>]

    measure_ids = set(measure_dict.keys())
    target_measure_ids = measure_ids.difference(input_measure_ids)

    df_list = []
    for area_id in area_dict:
        start_date, end_date = None, None

        # trick: 0 is used as DEFAULT datetime for all areas
        if 0 in start_end_dates:
            start_date, end_date = start_end_dates[0]
        if area_id in start_end_dates:
            start_date, end_date = start_end_dates[area_id]
        if start_date is None:
            # no start/end dates is found
            continue

        date_index = pd.date_range(start=start_date, end=end_date, freq=freq)
        for skill_id in skill_dict:
            area_skill_df = DataFrame(data={
                'area_id_fk': area_id,
                'skill_id_fk': skill_id,
                'time': date_index.to_series()
            })
            area_skill_df['day'] = area_skill_df['time'].dt.day_name()
            for input_id in input_measure_ids:
                area_skill_df[str(input_id)] = defval

            for target_id in target_measure_ids:
                area_skill_df[str(target_id)] = defval

            df_list.append(area_skill_df)

    df_pred = pd.concat(df_list, axis=0, ignore_index=True).reset_index(drop=True)
    return df_pred


def _compose_predict_df_new_format(
    df_past: DataFrame,
    area_dict: dict[int, str],
    skill_dict: dict[int, str],
    input_measure_ids: list[int],
    measure_dict: dict[int, str],
    start_end_dates: dict[int, tuple[datetime, datetime]],
    freq: Literal['D', 'W', 'M'],
    defval: Union[None, float] = 0.) -> DataFrame:
    # columns: ['area', 'skill', 'date', <measure_name>]

    measure_ids = set(measure_dict.keys())
    target_measure_ids = measure_ids.difference(input_measure_ids)

    df_list = []
    for area_id in area_dict:
        start_date, end_date = None, None

        # trick: 0 is used as DEFAULT datetime for all areas
        if 0 in start_end_dates:
            start_date, end_date = start_end_dates[0]
        if area_id in start_end_dates:
            start_date, end_date = start_end_dates[area_id]
        if start_date is None:
            # no start/end dates is found
            continue

        #  FutureWarning: 'M' is deprecated and will be removed in a future version, please use 'ME' instead.
        #   MS: MonthBegin
        #   ME: MonthEnd
        if freq == 'M': freq = 'MS'

        date_index = pd.date_range(start=start_date, end=end_date, freq=freq)
        for skill_id in skill_dict:
            area_skill_df = DataFrame(data={
                'area': area_dict[area_id],
                'skill': skill_dict[skill_id],
                'date': date_index.to_series()
            })
            for input_id in input_measure_ids:
                input_name = measure_dict[input_id]
                area_skill_df[input_name] = defval
            for target_id in target_measure_ids:
                target_name = measure_dict[target_id]
                area_skill_df[target_name] = defval

            df_list.append(area_skill_df)

    df_pred = pd.concat(df_list, axis=0, ignore_index=True).reset_index(drop=True)
    return df_pred
